[{"permalink":"//","layout":"default","title":"Página Proyectos de José Juan","content":"# Página Proyectos de José Juan ","dir":"/","name":"README.md","path":"README.md","url":"/"},{"permalink":"/bbdd/","layout":"default","title":"BASE DE DATOS","content":"# BASE DE DATOS\n\n## Apartado de Administración de Sistemas Gestores de Bases de Datos de José Juan Hervás Carrasco.","dir":"/bbdd/","name":"README.md","path":"bbdd/README.md","url":"/bbdd/"},{"layout":"default","title":"INTERCONEXIÓN DE SERVIDORES","content":"# INTERCONEXIÓN DE SERVIDORES\n\n## Introducción\n\nEn esta práctica veremos varias formas de crear un enlace entre distintos servidores de bases de datos.\n\nSe pide:\n\n- Realizar un enlace entre dos servidores de bases de datos ORACLE, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.\n \n- Realizar un enlace entre dos servidores de bases de datos Postgres, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.\n \n- Realizar un enlace entre un servidor ORACLE y otro Postgres empleando Heterogeneus Services, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.\n\n## Interconexión entre dos servidores Oracle.\n\nLo primero que haremos en este punto es crear dos bases de datos en cada uno de los servidores de oracle y las conectaremos entre sí. Para ello seguiremos los correspondientes pasos:\n\n- Primero creamos un usuario en la maquina oracle1 otorgandole todos los privilegios:\n\n ```sql\n SQL> CREATE USER joseju10 IDENTIFIED BY joseju10;\n\n Usuario creado.\n\n SQL> GRANT ALL PRIVILEGES TO joseju10;\n\n Concesion terminada correctamente.\n ```\n\n- Posteriormente, nos conectamos al usuario recién creado:\n\n ```sql\n SQL> DISCONNECT\n Desconectado de Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production\n Version 19.3.0.0.0\n SQL> CONNECT joseju10/joseju10\n Conectado.\n ```\n\n- Crearemos una base de datos de ejemplo, en este caso el esquema SCOTT:\n\n ```sql\n CREATE TABLE DEPT\n (\n DEPTNO NUMBER(2),\n DNAME VARCHAR2(14),\n LOC VARCHAR2(13),\n CONSTRAINT PK_DEPT PRIMARY KEY (DEPTNO)\n );\n\n CREATE TABLE EMP\n (\n EMPNO NUMBER(4),\n ENAME VARCHAR2(10),\n JOB VARCHAR2(9),\n MGR NUMBER(4),\n HIREDATE DATE,\n SAL NUMBER(7, 2),\n COMM NUMBER(7, 2),\n DEPTNO NUMBER(2),\n CONSTRAINT FK_DEPTNO FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO),\n CONSTRAINT PK_EMP PRIMARY KEY (EMPNO)\n );\n\n INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');\n INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS');\n INSERT INTO DEPT VALUES (30, 'SALES', 'CHICAGO');\n INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');\n\n INSERT INTO EMP VALUES(7369, 'SMITH', 'CLERK', 7902,TO_DATE('17-DIC-1980', 'DD-MON-YYYY'), 800, NULL, 20);\n INSERT INTO EMP VALUES(7499, 'ALLEN', 'SALESMAN', 7698,TO_DATE('20-FEB-1981', 'DD-MON-YYYY'), 1600, 300, 30);\n INSERT INTO EMP VALUES(7521, 'WARD', 'SALESMAN', 7698,TO_DATE('22-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 30);\n INSERT INTO EMP VALUES(7566, 'JONES', 'MANAGER', 7839,TO_DATE('2-ABR-1981', 'DD-MON-YYYY'), 2975, NULL, 20);\n INSERT INTO EMP VALUES(7654, 'MARTIN', 'SALESMAN', 7698,TO_DATE('28-SEP-1981', 'DD-MON-YYYY'), 1250, 1400, 30);\n INSERT INTO EMP VALUES(7698, 'BLAKE', 'MANAGER', 7839,TO_DATE('1-MAY-1981', 'DD-MON-YYYY'), 2850, NULL, 30);\n INSERT INTO EMP VALUES(7782, 'CLARK', 'MANAGER', 7839,TO_DATE('9-JUN-1981', 'DD-MON-YYYY'), 2450, NULL, 10);\n INSERT INTO EMP VALUES(7788, 'SCOTT', 'ANALYST', 7566,TO_DATE('09-DIC-1982', 'DD-MON-YYYY'), 3000, NULL, 20);\n INSERT INTO EMP VALUES(7839, 'KING', 'PRESIDENT', NULL,TO_DATE('17-NOV-1981', 'DD-MON-YYYY'), 5000, NULL, 10);\n INSERT INTO EMP VALUES(7844, 'TURNER', 'SALESMAN', 7698,TO_DATE('8-SEP-1981', 'DD-MON-YYYY'), 1500, 0, 30);\n INSERT INTO EMP VALUES(7876, 'ADAMS', 'CLERK', 7788,TO_DATE('12-ENE-1983', 'DD-MON-YYYY'), 1100, NULL, 20);\n INSERT INTO EMP VALUES(7900, 'JAMES', 'CLERK', 7698,TO_DATE('3-DIC-1981', 'DD-MON-YYYY'), 950, NULL, 30);\n INSERT INTO EMP VALUES(7902, 'FORD', 'ANALYST', 7566,TO_DATE('3-DIC-1981', 'DD-MON-YYYY'), 3000, NULL, 20);\n INSERT INTO EMP VALUES(7934, 'MILLER', 'CLERK', 7782,TO_DATE('23-ENE-1982', 'DD-MON-YYYY'), 1300, NULL, 10);\n\n COMMIT;\n ```\n\nRealizamos el mismo procedimiento en oracle2, creando el usuario joseju20, y el esquema SCOTT modificando los inserts:\n\n- Creo usuario:\n\n ```sql\n SQL> CREATE USER joseju20 IDENTIFIED BY joseju20;\n\n Usuario creado.\n\n SQL> GRANT ALL PRIVILEGES TO joseju20;\n\n Concesion terminada correctamente.\n ```\n\n- Nos conectamos al usuario y creamos la siguiente base de datos:\n\n ```sql\n CREATE TABLE DEPT\n (\n DEPTNO NUMBER(2),\n DNAME VARCHAR2(14),\n LOC VARCHAR2(13),\n CONSTRAINT PK_DEPT PRIMARY KEY (DEPTNO)\n );\n\n CREATE TABLE EMP\n (\n EMPNO NUMBER(4),\n ENAME VARCHAR2(10),\n JOB VARCHAR2(9),\n MGR NUMBER(4),\n HIREDATE DATE,\n SAL NUMBER(7, 2),\n COMM NUMBER(7, 2),\n DEPTNO NUMBER(2),\n CONSTRAINT FK_DEPTNO FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO),\n CONSTRAINT PK_EMP PRIMARY KEY (EMPNO)\n );\n\n INSERT INTO DEPT VALUES (50, 'RECOUNTING', 'MIAMI');\n INSERT INTO DEPT VALUES (60, 'SEARCH', 'FLORIDA');\n INSERT INTO DEPT VALUES (70, 'SHELLS', 'NEW JERSEY');\n INSERT INTO DEPT VALUES (80, 'OPTIONS', 'WASHINTON');\n\n INSERT INTO EMP VALUES(7379, 'LEON', 'EMPLOY', 7902,TO_DATE('18-DIC-1980', 'DD-MON-YYYY'), 800, NULL, 60);\n INSERT INTO EMP VALUES(7419, 'NEIL', 'SALESMAN', 7698,TO_DATE('21-FEB-1981', 'DD-MON-YYYY'), 1600, 300, 80);\n INSERT INTO EMP VALUES(7531, 'RICKY', 'SALESMAN', 7698,TO_DATE('23-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 80);\n INSERT INTO EMP VALUES(7576, 'STONE', 'MANAGER', 7839,TO_DATE('3-ABR-1981', 'DD-MON-YYYY'), 2975, NULL, 70);\n INSERT INTO EMP VALUES(7664, 'NAVARRO', 'SALESMAN', 7698,TO_DATE('29-SEP-1981', 'DD-MON-YYYY'), 1250, 1400, 80);\n INSERT INTO EMP VALUES(7618, 'JAKE', 'MANAGER', 7839,TO_DATE('2-MAY-1981', 'DD-MON-YYYY'), 2850, NULL, 80);\n INSERT INTO EMP VALUES(7792, 'CLEIRK', 'MANAGER', 7839,TO_DATE('10-JUN-1981', 'DD-MON-YYYY'), 2450, NULL, 50);\n INSERT INTO EMP VALUES(7798, 'STITS', 'ANALYST', 7566,TO_DATE('8-DIC-1982', 'DD-MON-YYYY'), 3000, NULL, 60);\n INSERT INTO EMP VALUES(7899, 'REPS', 'PRESIDENT', NULL,TO_DATE('1-NOV-1981', 'DD-MON-YYYY'), 5000, NULL, 50);\n INSERT INTO EMP VALUES(7854, 'TURNOR', 'SALESMAN', 7698,TO_DATE('18-SEP-1981', 'DD-MON-YYYY'), 1500, 0, 70);\n INSERT INTO EMP VALUES(7886, 'EVA', 'CLERK', 7788,TO_DATE('1-ENE-1983', 'DD-MON-YYYY'), 1100, NULL, 60);\n INSERT INTO EMP VALUES(7910, 'PETER', 'CLERK', 7698,TO_DATE('13-DIC-1981', 'DD-MON-YYYY'), 950, NULL, 80);\n INSERT INTO EMP VALUES(7912, 'HENRY', 'ANALYST', 7566,TO_DATE('23-DIC-1981', 'DD-MON-YYYY'), 3000, NULL, 60);\n INSERT INTO EMP VALUES(7944, 'MULLER', 'CLERK', 7782,TO_DATE('3-ENE-1982', 'DD-MON-YYYY'), 1300, NULL, 50);\n\n COMMIT;\n ```\n\nUna vez hemos creado los respectivos usuarios con cada base de datos, procederemos a conectar nuestro oracle1 con oracle2, para ello haremos lo siguiente:\n\n- Compruebo la conectividad de oracle1 a oracle2:\n\n ```sql\n oracle@oracle:~$ tnsping 192.168.1.19\n\n TNS Ping Utility for Linux: Version 19.0.0.0.0 - Production on 23-NOV-2022 12:55:11\n\n Copyright (c) 1997, 2019, Oracle. All rights reserved.\n\n\n Used parameter files:\n /opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora\n\n Used HOSTNAME adapter to resolve the alias\n Attempting to contact (DESCRIPTION=(CONNECT_DATA=(SERVICE_NAME=))(ADDRESS=(PROTOCOL=tcp)(HOST=192.168.1.19)(PORT=1521)))\n OK (10 msec)\n ```\n\n- Como hemos podido comprobar, tenemos conectividad, con lo que procederemos a modificar el fichero de configuración /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora añadiendo la siguiente línea para indicar el servidor de oracle2:\n\n ```shell\n ORACLE2 =\n (DESCRIPTION =\n (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.19)(PORT = 1521))\n (CONNECT_DATA =\n (SERVER = DEDICATED)\n (SERVICE_NAME = ORCLCDB)\n )\n )\n ```\n\n- Ahora, iniciamos sesión con nuestro usuario creado anteriormente y ejecutamos el siguiente comando para establecer la conexión con oracle2:\n\n ```sql\n oracle@oracle:~$ sqlplus joseju10/joseju10\n\n SQL*Plus: Release 19.0.0.0.0 - Production on Wed Nov 23 13:39:07 2022\n Version 19.3.0.0.0\n\n Copyright (c) 1982, 2019, Oracle. All rights reserved.\n\n Hora de Ultima Conexion Correcta: Mie Nov 23 2022 12:47:31 +01:00\n\n Conectado a:\n Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production\n Version 19.3.0.0.0\n\n SQL> CREATE DATABASE LINK oracle2link\n CONNECT TO joseju20 IDENTIFIED BY joseju20\n USING 'oracle2';\n\n Enlace con la base de datos creado.\n ```\n\nAhora conectaremos la base oracle2 con oracle1, para ello volvemos a realizar el mismo procedimiento:\n\n- Comprobamos la conectividad de oracle2 a oracle1:\n\n ```shell\n oracle@oracle2:~$ tnsping 192.168.1.43\n\n TNS Ping Utility for Linux: Version 19.0.0.0.0 - Production on 23-NOV-2022 14:12:10\n\n Copyright (c) 1997, 2019, Oracle. All rights reserved.\n\n Used parameter files:\n /opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora\n\n Used HOSTNAME adapter to resolve the alias\n Attempting to contact (DESCRIPTION=(CONNECT_DATA=(SERVICE_NAME=))(ADDRESS=(PROTOCOL=tcp)(HOST=192.168.1.43)(PORT=1521)))\n OK (20 msec)\n ```\n\n- Añadimos esta línea en el fichero tnnames.ora de la máquina oracle2:\n\n ```shell\n ORACLE1 =\n (DESCRIPTION =\n (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.43)(PORT = 1521))\n (CONNECT_DATA =\n (SERVER = DEDICATED)\n (SERVICE_NAME = ORCLCDB)\n )\n )\n ```\n\n- Interconectamos la base de oracle1 con oracle2:\n\n ```sql\n oracle@oracle2:~$ sqlplus joseju20/joseju20\n\n SQL*Plus: Release 19.0.0.0.0 - Production on Wed Nov 23 13:49:56 2022\n Version 19.3.0.0.0\n\n Copyright (c) 1982, 2019, Oracle. All rights reserved.\n\n Hora de Ultima Conexion Correcta: Mie Nov 23 2022 13:35:00 +01:00\n\n Conectado a:\n Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production\n Version 19.3.0.0.0\n\n SQL> CREATE DATABASE LINK oracle1link\n CONNECT TO joseju10 IDENTIFIED BY joseju10\n USING 'oracle1';\n\n Enlace con la base de datos creado.\n ```\n\n- Ahora para comprobar que todo funciona, desde oracle1 haremos una consulta a la tabla dept de oracle2:\n\n ```sql\n SQL> select *\n 2 from dept@oracle2link;\n\n DEPTNO DNAME\t LOC\n ---------- -------------- -------------\n 50 RECOUNTING MIAMI\n 60 SEARCH\t FLORIDA\n 70 SHELLS\t NEW JERSEY\n 80 OPTIONS\t WASHINTON\n ```\n\n- Realizamos la misma prueba desde oracle2 hasta oracle1:\n\n ```sql\n SQL> select * \n 2 from dept@oracle1link;\n\n DEPTNO DNAME\t LOC\n ---------- -------------- -------------\n 10 ACCOUNTING\t NEW YORK\n 20 RESEARCH\t DALLAS\n 30 SALES\t CHICAGO\n 40 OPERATIONS\t BOSTON\n ```\n\n## Interconexión entre dos servidores de datos Postgres.\n\nLo primero que haremos en este punto es crear dos bases de datos en cada uno de los servidores de postgres y las conectaremos entre sí. Para ello seguiremos los correspondientes pasos:\n\n- Primero creamos la base de datos en postgres1:\n\n ```sql\n postgres@postgres1:~$ psql\n psql (13.8 (Debian 13.8-0+deb11u1))\n Digite «help» para obtener ayuda.\n\n postgres=# CREATE DATABASE postgres1;\n CREATE DATABASE\n ```\n\n- Seguidamente, creamos el usuario \"postgres1\" y le damos privilegios sobre la base de datos creada anteriormente:\n\n ```sql\n postgres=# CREATE USER postgres1 WITH PASSWORD 'postgres';\n CREATE ROLE\n postgres=# GRANT ALL PRIVILEGES ON DATABASE postgres1 TO postgres1;\n GRANT\n ```\n\n- Ahora procedemos a acceder con el usuario recién creado:\n\n ```sql\n postgres@postgres1:~$ psql -h localhost -U postgres1 -d postgres1\n Contraseña para usuario postgres1: \n psql (13.8 (Debian 13.8-0+deb11u1))\n Conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, bits: 256, compresión: desactivado)\n Digite «help» para obtener ayuda.\n\n postgres1=>\n ```\n\n- Y creamos la tablas con su correspondiente información:\n\n ```sql\n postgres1=> CREATE TABLE DEPT\n (DEPTNO NUMERIC(2),\n DNAME VARCHAR(14),\n LOC VARCHAR(13),\n CONSTRAINT PK_DEPT PRIMARY KEY (DEPTNO));\n CREATE TABLE\n\n postgres1=> postgres1=> CREATE TABLE EMP\n (EMPNO NUMERIC(4),\n ENAME VARCHAR(10),\n JOB VARCHAR(9),\n MGR NUMERIC(4),\n HIREDATE DATE,\n SAL NUMERIC(7, 2),\n COMM NUMERIC(7, 2),\n DEPTNO NUMERIC(2),\n CONSTRAINT FK_DEPTNO FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO),\n CONSTRAINT PK_EMP PRIMARY KEY (EMPNO));\n CREATE TABLE\n\n postgres1=> INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');\n INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS');\n INSERT INTO DEPT VALUES (30, 'SALES', 'CHICAGO');\n INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');\n\n postgres1=> INSERT INTO EMP VALUES(7499, 'ALLEN', 'SALESMAN', 7698,TO_DATE('20-FEB-1981', 'DD-MON-YYYY'), 1600, 300, 30);\n INSERT INTO EMP VALUES(7521, 'WARD', 'SALESMAN', 7698,TO_DATE('22-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 30);\n INSERT INTO EMP VALUES(7654, 'MARTIN', 'SALESMAN', 7698,TO_DATE('28-SEP-1981', 'DD-MON-YYYY'), 1250, 1400, 30);\n INSERT INTO EMP VALUES(7698, 'BLAKE', 'MANAGER', 7839,TO_DATE('1-MAY-1981', 'DD-MON-YYYY'), 2850, NULL, 30);\n INSERT INTO EMP VALUES(7782, 'CLARK', 'MANAGER', 7839,TO_DATE('9-JUN-1981', 'DD-MON-YYYY'), 2450, NULL, 10);\n INSERT INTO EMP VALUES(7839, 'KING', 'PRESIDENT', NULL,TO_DATE('17-NOV-1981', 'DD-MON-YYYY'), 5000, NULL, 10);\n INSERT INTO EMP VALUES(7844, 'TURNER', 'SALESMAN', 7698,TO_DATE('8-SEP-1981', 'DD-MON-YYYY'), 1500, 0, 30);\n ```\n\nAhora procederemos a hacer lo mismo en postgres2:\n\n- Creamos base de datos:\n\n ```sql\n postgres@postgres2:~$ psql\n psql (13.8 (Debian 13.8-0+deb11u1))\n Digite «help» para obtener ayuda.\n\n postgres=# CREATE DATABASE postgres2;\n CREATE DATABASE\n ```\n\n- Creamos el usuario:\n\n ```sql\n postgres=# CREATE USER postgres2 WITH PASSWORD 'postgres';\n CREATE ROLE\n postgres=# GRANT ALL PRIVILEGES ON DATABASE postgres2 TO postgres2;\n GRANT\n ```\n\n- Accedemos con el usuario recién creado:\n\n ```sql\n postgres@postgres2:~$ psql -h localhost -U postgres2 -d postgres2\n Contraseña para usuario postgres2: \n psql (13.8 (Debian 13.8-0+deb11u1))\n Conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, bits: 256, compresión: desactivado)\n Digite «help» para obtener ayuda.\n\n postgres2=>\n ```\n\n- Y creamos las tablas con su correspondiente información:\n\n ```sql\n postgres2=> CREATE TABLE DEPT\n (DEPTNO NUMERIC(2),\n DNAME VARCHAR(14),\n LOC VARCHAR(13),\n CONSTRAINT PK_DEPT PRIMARY KEY (DEPTNO));\n CREATE TABLE\n\n postgres2=> CREATE TABLE EMP\n (EMPNO NUMERIC(4),\n ENAME VARCHAR(10),\n JOB VARCHAR(9),\n MGR NUMERIC(4),\n HIREDATE DATE,\n SAL NUMERIC(7, 2),\n COMM NUMERIC(7, 2),\n DEPTNO NUMERIC(2),\n CONSTRAINT FK_DEPTNO FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO),\n CONSTRAINT PK_EMP PRIMARY KEY (EMPNO));\n CREATE TABLE\n\n postgres2=> INSERT INTO DEPT VALUES (50, 'RECOUNTING', 'MIAMI');\n INSERT INTO DEPT VALUES (60, 'SEARCH', 'FLORIDA');\n INSERT INTO DEPT VALUES (70, 'SHELLS', 'NEW JERSEY');\n INSERT INTO DEPT VALUES (80, 'OPTIONS', 'WASHINTON');\n\n postgres2=> INSERT INTO EMP VALUES(7419, 'NEIL', 'SALESMAN', 7698,TO_DATE('21-FEB-1981', 'DD-MON-YYYY'), 1600, 300, 80);\n INSERT INTO EMP VALUES(7531, 'RICKY', 'SALESMAN', 7698,TO_DATE('23-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 80);\n INSERT INTO EMP VALUES(7664, 'NAVARRO', 'SALESMAN', 7698,TO_DATE('29-SEP-1981', 'DD-MON-YYYY'), 1250, 1400, 80);\n INSERT INTO EMP VALUES(7618, 'JAKE', 'MANAGER', 7839,TO_DATE('2-MAY-1981', 'DD-MON-YYYY'), 2850, NULL, 80);\n INSERT INTO EMP VALUES(7792, 'CLEIRK', 'MANAGER', 7839,TO_DATE('10-JUN-1981', 'DD-MON-YYYY'), 2450, NULL, 50);\n INSERT INTO EMP VALUES(7899, 'REPS', 'PRESIDENT', NULL,TO_DATE('1-NOV-1981', 'DD-MON-YYYY'), 5000, NULL, 50);\n INSERT INTO EMP VALUES(7854, 'TURNOR', 'SALESMAN', 7698,TO_DATE('18-SEP-1981', 'DD-MON-YYYY'), 1500, 0, 70);\n ```\n\nAhora que hemos creado las dos bases de datos con sus respetivos usuarios, procederemos a conectarlas entre sí, para ello haremos lo siguiente:\n\n- Dentro del fichero de configuración /etc/postgresql/13/main/postgresql.conf se buscamos la siguiente directiva:\n\n ```shell\n listen_addresses = 'localhost' # what IP address(es) to listen on;\n ```\n\n- Modificamos la palabra \"localhost\" por \"*\":\n\n ```shell\n listen_addresses = '*' # what IP address(es) to listen on;\n ```\n\n- Seguidamente, procedemos a modificar el fichero /etc/postgresql/13/main/pg_hba.conf, con la siguiente información:\n\n ```shell\n host replication all 127.0.0.1/32 md5\n ```\n\n- Modificamos los parámetros por los siguientes:\n\n ```shell\n host all all all md5\n ```\n\n- Reiniciamos el servicio de postgres y comprobamos mediante netstat que el puerto de postgres está bien configurado:\n\n ```shell\n root@postgres1:~# systemctl restart postgresql\n root@postgres1:~# netstat -tln\n Active Internet connections (only servers)\n Proto Recv-Q Send-Q Local Address Foreign Address State \n tcp 0 0 0.0.0.0:5432 0.0.0.0:* LISTEN\n ```\n\nSeguimos los mismos pasos que hicimos anteriormente en la máquina postgres2 modificando los ficheros postgresql.conf y pg_hba.conf de la misma forma que explicamos anteriormente y comprobamos mediante netstat que todo funciona:\n\n- Comprobamos:\n\n ```shell\n root@postgres2:~# /var/lib/postgresql# systemctl restart postgresql\n root@postgres2:~# /var/lib/postgresql# netstat -tln\n Active Internet connections (only servers)\n Proto Recv-Q Send-Q Local Address Foreign Address State \n tcp 0 0 0.0.0.0:5432 0.0.0.0:* LISTEN \n ```\n\nAhora que hemos configurado el servicio postgres en ambas máquinas para permitir conexiones remotas, procederemos a interconectar las bases de datos creadas anteriormente entre si. Para ello primero instalamos el siguiente paquete en ambas máquinas:\n\n```shell\nroot@postgres1:~# apt install postgresql-contrib\n\nroot@postgres2:~# apt install postgresql-contrib\n```\n\nPosteriormente, configuraremos ambas máquinas para crear un enlace entre ellas:\n\n- Accedemos a la base de datos \"postgres1\":\n\n ```sql\n postgres@postgres1:~$ psql -d postgres1\n psql (13.8 (Debian 13.8-0+deb11u1))\n Digite «help» para obtener ayuda.\n\n postgres1=# \n ```\n\n- Creamos el siguiente link:\n\n ```sql\n postgrest1=# CREATE EXTENSION dblink;\n CREATE EXTENSION\n ```\n\n- Realizamos el mismo procedimiento en postgres2:\n\n ```sql\n postgres@postgres2:~$ psql -d postgres2\n psql (13.8 (Debian 13.8-0+deb11u1))\n Digite «help» para obtener ayuda.\n\n postgres2=# CREATE EXTENSION dblink;\n CREATE EXTENSION\n ```\n\nFinalmente comprobamos que funciona haciendo una consulta a la tabla dept desde postgres1 a postgres2 y viceversa:\n\n- Select a postgres2:\n\n ```sql\n postgres1=# SELECT *\n FROM dblink('dbname=postgres2 host=192.168.1.22 user=postgres2 password=postgres','SELECT deptno,dname FROM dept') AS P(deptno NUMERIC(2),dname VARCHAR(14));\n deptno | dname \n --------+------------\n 50 | RECOUNTING\n 60 | SEARCH\n 70 | SHELLS\n 80 | OPTIONS\n (4 filas)\n ```\n\n- Select a postgres1:\n\n ```sql\n postgres2=# SELECT *\n postgres2-# FROM dblink('dbname=postgres1 host=192.168.1.23 user=postgres1 password=postgres','SELECT deptno,dname FROM dept') AS P(deptno NUMERIC(2),dname VARCHAR(14));\n deptno | dname \n --------+------------\n 10 | ACCOUNTING\n 20 | RESEARCH\n 30 | SALES\n 40 | OPERATIONS\n (4 filas)\n ```\n\n## Interconexión entre un servidor Oracle y otro Postgres.\n\nEn este punto inteconectararemos la base de datos creada en oracle1 con postgres2, para ello haremos lo siguiente:\n\n- Primero instalamos la paquetería necesaria para configurar los drivers:\n\n ```shell\n apt install unixodbc odbc-postgres\n ```\n\nA continuación, debemos configurar unixodbc para conectar los drivers, haremos lo siguiente:\n\n- Nos fijamos en la siguiente línea dentro del fichero de configuración /etc/odbcinst.ini:\n\n ```shell\n [PostgreSQL Unicode]\n ```\n\n- Aquí viene el nombre de los drivers de postgres, con lo que teniendo en cuenta esta información, añadimos la siguiente línea dentro del fichero /etc/odbc.ini:\n \n ```shell\n [PSQLU]\n Debug = 0\n CommLog = 0\n ReadOnly = 0\n Driver = PostgreSQL\n Servername = 192.168.1.22\n Username = postgres2\n Password = postgres\n Port = 5432\n Database = postgres2\n Trace = 0\n TraceFile = /tmp/sql.log\n ```\n\n- Comprobamos que hay conectividad:\n\n ```shell\n root@oracle:~# isql PSQLU\n +---------------------------------------+\n | Connected! |\n | |\n | sql-statement |\n | help [tablename] |\n | quit |\n | |\n +---------------------------------------+\n SQL> select * from dept;\n +-------+---------------+--------------+\n | deptno| dname | loc |\n +-------+---------------+--------------+\n | 50 | RECOUNTING | MIAMI |\n | 60 | SEARCH | FLORIDA |\n | 70 | SHELLS | NEW JERSEY |\n | 80 | OPTIONS | WASHINTON |\n +-------+---------------+--------------+\n SQLRowCount returns 4\n 4 rows fetched\n ```\nAhora que hemos configurado el driver, procederemos a configurar oracle para que utilice el driver, para ello haremos lo siguiente:\n\n- Dentro del directorio /opt/oracle/product/19c/dbhome_1/hs/admin/ creamos el fichero initPSQLU.ora con el siguiente contenido:\n\n ```shell\n HS_FDS_CONNECT_INFO = PSQLU\n HS_FDS_TRACE_LEVEL = DEBUG\n HS_FDS_SHAREABLE_NAME = /usr/lib64/psqlodbcw.so\n HS_LANGUAGE = AMERICAN_AMERICA.WE8ISO8859P1\n set ODBCINI=/etc/odbc.ini\n ```\n\n- Seguidamente, modificamos el fichero de configuración /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora con el siguiente contenido:\n\n ```shell\n SID_LIST_LISTENER =\n (SID_LIST =\n (SID_DESC =\n (SID_NAME = PSQLU)\n (ORACLE_HOME = /opt/oracle/product/19c/dbhome_1)\n (PROGRAM = dg4odbc)\n )\n )\n ```\n\n- A continuación, dentro del fichero tnsnames.ora, añadimos lo siguiente:\n\n ```shell\n PSQLU =\n (DESCRIPTION=\n (ADDRESS=(PROTOCOL=tcp)(HOST=localhost)(PORT=1521))\n (CONNECT_DATA=(SID=PSQLU))\n (HS=OK)\n )\n ```\n- Ahora reiniciamos oracle:\n\n ```shell\n oracle@oracle:~$ lsnrctl stop\n\n LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 23-NOV-2022 20:44:24\n\n Copyright (c) 1991, 2019, Oracle. All rights reserved.\n\n Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=0.0.0.0)(PORT=1521)))\n The command completed successfully\n oracle@oracle:~$ lsnrctl start\n\n LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 23-NOV-2022 20:44:27\n\n Copyright (c) 1991, 2019, Oracle. All rights reserved.\n\n Starting /opt/oracle/product/19c/dbhome_1/bin/tnslsnr: please wait...\n\n TNSLSNR for Linux: Version 19.0.0.0.0 - Production\n System parameter file is /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora\n Log messages written to /opt/oracle/diag/tnslsnr/oracle/listener/alert/log.xml\n Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))\n Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))\n\n Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=0.0.0.0)(PORT=1521)))\n STATUS of the LISTENER\n ------------------------\n Alias LISTENER\n Version TNSLSNR for Linux: Version 19.0.0.0.0 - Production\n Start Date 23-NOV-2022 20:44:27\n Uptime 0 days 0 hr. 0 min. 0 sec\n Trace Level off\n Security ON: Local OS Authentication\n SNMP OFF\n Listener Parameter File /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora\n Listener Log File /opt/oracle/diag/tnslsnr/oracle/listener/alert/log.xml\n Listening Endpoints Summary...\n (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))\n (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))\n Services Summary...\n Service \"PSQLU\" has 1 instance(s).\n Instance \"PSQLU\", status UNKNOWN, has 1 handler(s) for this service...\n The command completed successfully\n ```\n\n- Nos conectamos a oracle con nuestro usuario:\n\n ```sql\n oracle@oracle:~$ sqlplus joseju10/joseju10\n\n SQL*Plus: Release 19.0.0.0.0 - Production on Wed Nov 23 20:45:52 2022\n Version 19.3.0.0.0\n\n Copyright (c) 1982, 2019, Oracle. All rights reserved.\n\n Hora de Ultima Conexion Correcta: Mie Nov 23 2022 13:59:25 +01:00\n\n Conectado a:\n Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production\n Version 19.3.0.0.0\n\n SQL> \n ```\n- Creamos un link con la base de datos de postgres:\n\n ```sql \n SQL> CREATE DATABASE LINK postgreslink\n 2 CONNECT TO \"postgres2\" IDENTIFIED BY \"postgres\"\n 3 USING 'PSQLU';\n\n Enlace con la base de datos creado.\n ```\n- Hacemos un select a la tabla dept de postgres para comprobar que funciona:\n\n ```sql\n SQL> select *\n 2 from \"dept\"@postgreslink;\n\n DEPTNO DNAME\t LOC\n ---------- -------------- -------------\n 50 RECOUNTING MIAMI\n 60 SEARCH\t FLORIDA\n 70 SHELLS\t NEW JERSEY\n 80 OPTIONS\t WASHINTON\n ```\n\nAhora que hemos conectado oracle a postgres, lo configuraremos desde postgres a oracle, para ello haremos lo siguiente:\n\n- Primero instalamos los paquetes necesarios:\n\n ```shell\n postgres@postgres2:~$ apt install libaio1 postgresql-server-dev-all build-essential git\n ```\n- Seguidamente descargamos los siguientes archivos:\n\n ```shell\n postgres@postgres2:~$ wget https://download.oracle.com/otn_software/linux/instantclient/211000/instantclient-basic-linux.x64-21.1.0.0.0.zip\n\n postgres@postgres2:~$ wget https://download.oracle.com/otn_software/linux/instantclient/211000/instantclient-sdk-linux.x64-21.1.0.0.0.zip\n\n postgres@postgres2:~$ wget https://download.oracle.com/otn_software/linux/instantclient/211000/instantclient-sqlplus-linux.x64-21.1.0.0.0.zip\n ```\n- Descomprimimos los archivos recién descargados:\n\n ```shell\n postgres@postgres2:~$ unzip instantclient-basic-linux.x64-21.1.0.0.0.zip\n\n postgres@postgres2:~$ unzip instantclient-sqlplus-linux.x64-21.1.0.0.0.zip \n\n postgres@postgres2:~$ unzip instantclient-sdk-linux.x64-21.1.0.0.0.zip\n ```\n- Ahora exportaremos las siguientes variables de entorno:\n\n ```shell\n postgres@postgres2:~$ export ORACLE_HOME=/home/postgres2/instantclient_21_1\n postgres@postgres2:~$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME\n postgres@postgres2:~$ export PATH=$PATH:$ORACLE_HOME\n ```\n- Ahora nos intentamos conectar a nuestro usuario joseju10 de la máquina de oracle:\n\n ```sql\n postgres@postgres2:~$ sqlplus c###joseju10/joseju10@192.168.1.43/ORCLCDB\n\n SQL*Plus: Release 21.0.0.0.0 - Production on Wed Nov 23 21:12:23 2022\n Version 21.1.0.0.0\n\n Copyright (c) 1982, 2020, Oracle. All rights reserved.\n\n Hora de Ultima Conexion Correcta: Mie Nov 23 2022 20:45:52 +01:00\n\n Conectado a:\n Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production\n Version 19.3.0.0.0\n\n SQL>\n ```\nUna vez hemos comprobado que el cliente oracle funciona correctamente, procederemos a la compliación de oracle_fwd, para ello haremos lo siguiente:\n\n- Clonamos el siguiente repositorio:\n\n ```shell\n postgres@postgres2:~$ git clone https://github.com/laurenz/oracle_fdw.git\n Clonando en 'oracle_fdw'...\n remote: Enumerating objects: 2489, done.\n remote: Counting objects: 100% (343/343), done.\n remote: Compressing objects: 100% (124/124), done.\n remote: Total 2489 (delta 234), reused 324 (delta 219), pack-reused 2146\n Recibiendo objetos: 100% (2489/2489), 1.43 MiB | 1.13 MiB/s, listo.\n Resolviendo deltas: 100% (1708/1708), listo.\n ```\n- Accemos al directorio clonado y compilamos:\n\n ```shell\n postgres@postgres2:~/oracle_fdw$ make\n gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -g -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -fno-omit-frame-pointer -fPIC -I\"/home/postgres2/instantclient_21_1/sdk/include\" -I\"/home/postgres2/instantclient_21_1/oci/include\" -I\"/home/postgres2/instantclient_21_1/rdbms/public\" -I\"/home/postgres2/instantclient_21_1/\" -I. -I./ -I/usr/include/postgresql/13/server -I/usr/include/\n\n root@postgres2:/home/postgres/oracle_fdw# make install\n /bin/mkdir -p '/usr/lib/postgresql/13/lib'\n /bin/mkdir -p '/usr/share/postgresql/13/extension'\n /bin/mkdir -p '/usr/share/postgresql/13/extension'\n /bin/mkdir -p '/usr/share/doc/postgresql-doc-13/extension'\n /usr/bin/install -c -m 755 oracle_fdw.so '/usr/lib/postgresql/13/lib/oracle_fdw.so'\n /usr/bin/install -c -m 644 .//oracle_fdw.control '/usr/share/postgresql/13/extension/'\n /usr/bin/install -c -m 644 .//oracle_fdw--1.2.sql .//oracle_fdw--1.0--1.1.sql .//oracle_fdw--1.1--1.2.sql '/usr/share/postgresql/13/extension/'\n /usr/bin/install -c -m 644 .//README.oracle_fdw '/usr/share/doc/postgresql-doc-13/extension/'\n ```\n\n- Seguidamente, indicamos en el fichero de configuración oracle.conf el siguiente contenido para indicarle las librerías de Oracle:\n\n ```shell\n root@postgres2:/home/postgres/oracle_fdw# echo '/home/postgres/instantclient\\_21\\_1' | tee /etc/ld.so.conf.d/oracle.conf\n ```\n\nEn este punto ya tenemos configurado el apartado de datos con respecto a la configuración de postgres para acceder a oracle, lo que haremos será crear un esquema con el usuario por defecto de postgres copiando la base de datos que tenemos en oracle a un esquema que crearemos en este punto. \n\nA dicho esquema le otorgaremos los correspondientes permisos para que el usuario postgres2 pueda crear tablas, realizar consultas... Para ello seguiremos los siguientes pasos:\n\n- Creamos el enlace de la base de datos de oracle1 a posgres2, para ello accedemos a la base de datos postgres2:\n\n ```shell\n postgres@postgres2:~/oracle_fdw$ psql -d postgres2\n psql (13.8 (Debian 13.8-0+deb11u1))\n Digite «help» para obtener ayuda.\n\n postgres2=>\n ```\n- Creamos dicho enlace:\n\n ```sql\n postgres2=# CREATE EXTENSION oracle_fdw;\n CREATE EXTENSION\n ```\n- Generamos un esquema de nombre oracle:\n\n ```sql\n postgres2=# CREATE SCHEMA oracle;\n CREATE SCHEMA\n ```\n- Seguidamente, mapeamos el usuario local al usuario remoto de oracle:\n\n ```sql\n postgres2=# CREATE USER MAPPING FOR oracle SERVER oracle OPTIONS (user 'joseju10', password 'joseju10');\n CREATE USER MAPPING\n ```\n- Otorgamos permisos al usuario local postgres2:\n\n ```sql\n postgres2=# GRANT ALL PRIVILEGES ON SCHEMA oracle TO postgres2;\n GRANT\n ```\n ```sql\n postgres2=# GRANT ALL PRIVILEGES ON FOREIGN SERVER oracle TO postgres2;\n GRANT\n ```\n- Iniciamos sesión con el usuario postgres2:\n\n ```sql\n postgres2@postgres2:~$ psql -h localhost -U postgres2 -d postgres2\n Contraseña para usuario postgres2: \n psql (13.8 (Debian 13.8-0+deb11u1))\n Conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, bits: 256, compresión: desactivado)\n Digite «help» para obtener ayuda.\n\n postgres2=>\n ```\n- Importamos el esquema creado anteriormente:\n\n ```sql\n prueba2=# IMPORT FOREIGN SCHEMA \"joseju10\" FROM SERVER oracle INTO oracle;\n IMPORT FOREIGN SCHEMA\n ```\n- Finalmente realizamos una consulta a la tabla dept del servidor para comprobar si funciona:\n\n ```sql\n postgres1=> select *\n postgres1-> from dept;\n deptno | dname | loc \n --------+------------+----------\n 10 | ACCOUNTING | NEW YORK\n 20 | RESEARCH | DALLAS\n 30 | SALES | CHICAGO\n 40 | OPERATIONS | BOSTON\n (4 filas)\n ```","dir":"/bbdd/","name":"interconexion.md","path":"bbdd/interconexion.md","url":"/bbdd/interconexion.html"},{"permalink":"/sistemas/","layout":"default","title":"SISTEMAS OPERATIVOS","content":"# SISTEMAS OPERATIVOS\n\n## Apartado de Sistemas Operativos de José Juan Hervás Carrasco.","dir":"/sistemas/","name":"README.md","path":"sistemas/README.md","url":"/sistemas/"},{"layout":"default","title":"COMPILACION DE UN KERNEL LINUX A MEDIDA","content":"# COMPILACION DE UN KERNEL LINUX A MEDIDA\n\n## Introducción\n\nEn este apartado descargaremos una versión de kernel desde la página https://kernel.org/ y haremos lo siguiente:\n\n- Instalar dependencias\n\n- Descargar Kernel\n\n- Compilar Kernel\n\n- Crear imagen .deb\n\n- Instalar archivo .deb creado anteriormente\n\n- Reducir módulos del Kernel\n\nLa versión de Kernel que he elegido para este apartado es la versión 6.0.7.\n\n---\n\n## Instalar Dependencias\n\n---\n\nEn este punto lo primero que haremos será instalar los paquetes necesarios para poder compilar el kernel y posteriormente crear el fichero .deb correspondiente.\n\nPrimero actualizamos:\n\n```shell\njoseju@debian:~$ sudo apt update\n```\n\nInstalamos las dependencias:\n```shell\njoseju@debian:~$ sudo apt install build-essential qtbase5-dev libelf-dev pkg-config \n```\n\n---\n\n## Descargar Kernel\n\n---\n\nUna vez hemos instalado las correspondientes dependencias, descargaremos el archivo del kernel:\n\n```shell\njoseju@debian:~/compilacion_kernel$ wget https://mirrors.edge.kernel.org/pub/linux/kernel/v6.x/linux-6.0.7.tar.xz\n```\n\n---Reducir módulos del Kernel\n\njoseju@debian:~/compilacion_kernel$ tar -xvf linux-6.0.7.tar.xz\n```\n\nPosteriormente, accedemos a la carpeta y compilamos el archivo oldconfig:\n\n```shell\njoseju@debian:~/compilacion_kernel/linux-6.0.7$ make oldconfig\n```\n- Al compilarlo nos hará muchas preguntas, dejamos pulsado intro ya que por defecto indicamos que no.\n\nUna vez hecho esto, se nos habrá generado un fichero oculto llamado .config:\n\n```shell\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ ls -la | egrep '.config'\n-rw-r--r-- 1 usuario usuario 59 nov 3 16:00 .cocciconfig\n-rw-r--r-- 1 usuario usuario 252431 nov 17 14:12 .config\n-rw-r--r-- 1 usuario usuario 555 nov 3 16:00 Kconfig\n```\n\nEn este fichero se almacenan los módulos que vienen por defecto y que posteriormente deberemos ir desactivando, pero este no es el caso, asi que prodeceremos a compilar este archivo para reducir módulos automáticamente:\n\n```shell\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ make localmodconfig\n```\n\n---\n\n## Crear imagen .deb\n\n---\n\nAhora que hemos reducido los módulos, procederemos a generar nuestra imagen .deb del kernel, para ello:\n\n```shell\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ make -j12 bindeb-pkg\n```\n\n- Esto tardará un rato ya que antes de reducir considerablemente el número de módulos, se tienen que cargar los que vienen por defecto.\n\n---\n\n## Instalar archivo .deb creado anteriormente\n\n---\n\nPrimero, verificamos la versión del kernel que tenemos actualmente en funcionamiento:\n\n```shell\nusuario@debian:~$ uname -r\n5.10.0-18-amd64\n```\n\nAhora que hemos compilado y generado el fichero .deb, procederemos a instalar el fichero .deb que se nos ha generado y este se añadirá al grub como una nueva versión de kernel._\n\n```shell\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ sudo dpkg -i ../linux-image-6.0.7_6.0.7-1_amd64.deb\n```\n\nEn este punto reiniciamos la máquina y comprobamos que la nueva versión del kernel funciona correctmente\n\n```shell\nusuario@debian:~$ sudo reboot\n```\n\n---\n\n## Reducir módulos del Kernel\n\n---\n\nPrimero, comprobamos la versión de kernel actual tras el reinicio:\n\n```shell\nusuario@debian:~$ uname -r\n6.0.7\n```\n\nAhora que tenemos cargada la nueva versión de kernel en nuestro sistema operativo, debemos reducir el número de módulos a medida de las características del hardware de nuestro equipo.\n\nPor ejemplo nuestro equipo funciona con un procesador intel, pues los módulos que sean amd los podemos desactivar.\n\nAntes de editar los módulos, comprobamos los módulos que tiene actualmente el fichero .config:\n\n```shell\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ egrep '=y' .config | wc -l\n1627\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ egrep '=m' .config | wc -l\n193\n```\n\nPara editar los módulos del kernel ejecutamos el siguiente comando:\n\n```shell\nusuario@debian:~/compilacion_kernel/linux-6.0.7$ make xconfig\n```\n\nNos aparecerá una ventana gráfica donde deberemos ir desmarcando los módulos que sean necesarios.\n","dir":"/sistemas/","name":"compilacion-kernel.md","path":"sistemas/compilacion-kernel.md","url":"/sistemas/compilacion-kernel.html"}]